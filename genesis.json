import hashlib
import time

class KylecoinProtocol:
    def __init__(self):
        self.halving_interval = 3_000_000  # 5 Years, 8 Months
        self.initial_reward = 50.0        # KYLE per block
        self.block_time_target = 60       # Seconds
        
    def get_current_reward(self, block_height):
        """Calculates reward based on the 5y 8m cycle."""
        halvings = block_height // self.halving_interval
        if halvings >= 33: # Max supply reached
            return 0
        return self.initial_reward / (2 ** halvings)

    def validate_mining(self, block_height, score, difficulty):
        """Standard CPU Proof-of-Work validation."""
        reward = self.get_current_reward(block_height)
        # Mining logic here
        return reward
{
  "config": {
    "chainId": 888,
    "chainName": "FrosTether Mainnet",
    "genesisTimestamp": "2026-01-23T11:52:00Z",
    "difficulty": 15.0,
    "reward_logic": "Proof-of-Skill (PoS)"
  },
  "initialState": {
    "alloc": {
      "JacobFrost_Admin": { "balance": "1000000" }
    },
    "message": "Monroeville, Ohio - January 2026: The Frostner Lock is Engaged."
  },
  "nonce": "23",
  "previousHash": "0"
}import os
import hashlib

class FrostnerjoProtocol:
    def __init__(self):
        self.protocol_name = "Cryptonite"
        self.halving_interval = 3_000_000
        self.scratchpad_size = 2 * 1024 * 1024 # 2MB Cache Requirement
        
    def get_fnr_reward(self, height):
        """Matches the 5y 8m ecosystem standard."""
        return 100.0 / (2 ** (height // self.halving_interval))

    def crypto_night_hash(self, data):
        """Simulates memory-hard CPU mining."""
        # Scratchpad prevents ASIC dominance
        scratchpad = hashlib.sha256(data).digest() * 65536 
        result = hashlib.pbkdf2_hmac('sha256', data, scratchpad[:64], 2048)
        return result.hex()
def adjust_difficulty(previous_difficulty, actual_time, target_time):
    """
    Prevents the chain from moving too fast.
    If actual_time < target_time, difficulty increases.
    """
    adjustment_factor = target_time / actual_time
    # Cap the change to 4x to prevent volatility
    adjustment_factor = max(0.25, min(4.0, adjustment_factor))
    return previous_difficulty * adjustment_factor

