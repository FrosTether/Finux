import os
import re
import json
import subprocess
import datetime

# --- CONFIGURATION ---
ROOT_DIR = os.getcwd()
VERSION_FILE = "version.json"
TARGET_DIRS = ["mobile/kernel", "mobile/vault", "mobile/reactor", "mobile/fos"]

# COLORS
C_CYAN = "\033[96m"
C_GREEN = "\033[92m"
C_WARN = "\033[93m"
C_RESET = "\033[0m"

def log(msg, type="INFO"):
    prefix = "[*]"
    if type == "OK": prefix = f"[{C_GREEN}OK{C_RESET}]"
    if type == "WARN": prefix = f"[{C_WARN}!{C_RESET}]"
    if type == "ACTION": prefix = f"[{C_CYAN}>>{C_RESET}]"
    print(f"{prefix} {msg}")

def scan_and_fix_specs():
    """
    Scans buildozer.spec files to ensure 'requests' and 'web3' are included
    so the Grok OTA and Blockchain features don't crash.
    """
    log("Scanning Build Configurations...", "ACTION")
    
    patches_applied = 0
    
    for folder in TARGET_DIRS:
        spec_path = os.path.join(folder, "buildozer.spec")
        if os.path.exists(spec_path):
            with open(spec_path, "r") as f:
                content = f.read()
            
            # Check for missing libraries
            if "requests" not in content or "web3" not in content:
                log(f"Bug Detected in {folder}: Missing Dependencies", "WARN")
                
                # Regex to find the requirements line and append
                # This is a 'Heuristic Fix'
                new_content = re.sub(
                    r'(requirements\s*=.*)', 
                    r'\1,requests,web3', 
                    content
                )
                
                with open(spec_path, "w") as f:
                    f.write(new_content)
                
                log(f"Patched {folder}/buildozer.spec", "OK")
                patches_applied += 1
            else:
                log(f"{folder} Integrity Verified", "OK")
    
    if patches_applied == 0:
        log("No critical configuration bugs found.", "OK")

def bump_version():
    """
    Increments the version number in version.json for Grok OTA.
    """
    log("Preparing OTA Manifest...", "ACTION")
    
    current_ver = "v1.0"
    if os.path.exists(VERSION_FILE):
        with open(VERSION_FILE, "r") as f:
            data = json.load(f)
            current_ver = data.get("version", "v1.0")
    
    # Logic to bump version (v1.1 -> v1.2)
    # Simple parse for demo
    try:
        ver_num = float(current_ver.replace("v", "").split("-")[0])
        new_ver_num = round(ver_num + 0.1, 1)
        new_tag = f"v{new_ver_num}-Stable"
    except:
        new_tag = "v1.2-Stable"

    new_data = {
        "version": new_tag,
        "build": int(datetime.datetime.now().timestamp()),
        "channel": "OTA_HOTFIX",
        "changelog": "Automated Bug Fixes & Dependency Patch"
    }
    
    with open(VERSION_FILE, "w") as f:
        json.dump(new_data, f, indent=4)
        
    log(f"Version bumped: {current_ver} -> {new_tag}", "OK")
    return new_tag

def push_to_cloud(tag):
    """
    Commits changes and pushes the tag to GitHub.
    """
    log("Initiating Cloud Uplink...", "ACTION")
    
    cmds = [
        ["git", "add", "."],
        ["git", "commit", "-m", f"Hotfix: Automated System Repair {tag}"],
        ["git", "push", "origin", "main"],
        ["git", "tag", tag],
        ["git", "push", "origin", tag]
    ]
    
    for cmd in cmds:
        try:
            subprocess.run(cmd, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            log(
